{# THIS SECTION IS MACROS ONLY - NOT PRINTABLE #}
{%set FILTERED_ALIASES = ["VK_STENCIL_FRONT_AND_BACK", "VK_COLORSPACE_SRGB_NONLINEAR_KHR", "VK_QUERY_SCOPE_COMMAND_BUFFER_KHR", "VK_QUERY_SCOPE_COMMAND_KHR", "VK_QUERY_SCOPE_RENDER_PASS_KHR"]%}
{%set FILTERED_STRUCTS = ["AHardwareBuffer", "ANativeWindow"]%}
{%set ENABLED = true %}
{%set RETURN_STRUCT_FROM_SETTERS = false %}
{%macro open_ifdef(group)%}{%if group.ifdef%}
#ifdef {{group.ifdef}}
{%endif%}{%endmacro%}
{%macro close_ifdef(group)%}{%if group.ifdef%}
#endif // {{group.ifdef}}
{%endif%}{%endmacro%}
{##}
{# ##### MACRO - OUTPUT: Empty bitfield from TYPE ##### #}
{%macro output_empty_flags_from_type(type)%}{%if ENABLED%}
	{%set enumname = type.name|pvrvkify_type_name%}
	{%for group in type.groups%}{{open_ifdef(group)}}{%endfor%}
enum class {{ enumname }}: uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS({{enumname}})
DEFINE_EMPTY_TO_STRING({{enumname}})
	{%for group in type.groups | reverse%}{{close_ifdef(group)}}{%endfor%}

{%endif%}{%endmacro%}
{# #}
{# ##### MACRO - OUTPUT: Bitfield from ENUM ##### #}
{%macro output_enum_flag(enum)%}{%if ENABLED%}
	{% set enumname = enum.name|pvrvkify_type_name %}
	{%for group in enum.groups%}{{open_ifdef(group)}}{%endfor%}
enum class {{ enumname }}
{
	{%if "e_NONE" not in enum.values|map(attribute="name")|map("pvrvkify_enum_value", enum.name)%}
	e_NONE = 0,
	{%endif%}
	{%for value in enum.values%}
	{{value.name|pvrvkify_enum_value(enum.name)}} = {{value.name}},
	{%endfor%}
	{%for alias in enum.aliases if alias.name not in FILTERED_ALIASES%}
	{{alias.name|pvrvkify_enum_value(enum.name)}} = {{alias.name}},
	{%endfor%}
	{% set all_values = enum.values|map(attribute="name")|map("pvrvkify_enum_value", enum.name)|select("ne", "e_NONE")|list %}{%if all_values|length>0%}	e_ALL_BITS = {{all_values|join("|")}},
	{%endif%}
	e_MAX_ENUM = 0x7FFFFFFF
};
DEFINE_ENUM_BITWISE_OPERATORS({{enumname}})
inline std::string to_string({{enumname}} value)
{
	{%if enum.values|length==0 or (enum.values|length==1 and (enum.values|first).name == "VK_NONE") %}
	(void)value;
	{%endif%}
	std::string returnString = "";
	{%for value in enum.values%}
	append_to_string_flag(value, returnString, {{enumname}}::{{value.name|pvrvkify_enum_value(enum.name)}}, "{{value.name}}");
	{%endfor%}
	return returnString;
}
	{%for group in enum.groups | reverse%}{{close_ifdef(group)}}{%endfor%}

{%endif%}{%endmacro%}
{# #}
{# ##### MACRO - OUTPUT TYPE: Enum (NON-bitfield) ##### #}
{%macro output_enum(enum)%}{%if ENABLED%}
	{% set enumname = enum.name|pvrvkify_type_name %}
	{%for group in enum.groups%}{{open_ifdef(group)}}{%endfor%}
enum class {{ enumname }}
{
	{%for value in enum.values%}
	{{value.name|pvrvkify_enum_value(enum.name)}} = {{value.name}},
	{%endfor%}
	{%for alias in enum.aliases|unique|list if alias.name not in FILTERED_ALIASES%}
	{{alias.name|pvrvkify_enum_value(enum.name)}} = {{alias.name}},
	{%endfor%}
	e_MAX_ENUM = 0x7FFFFFFF
};
DEFINE_ENUM_BITWISE_OPERATORS({{enumname}})
inline std::string to_string({{enumname}} value)
{
	{%if enum.values|length==0 or (enum.values|length==1 and (enum.values|first).name == "VK_NONE") %}
	(void)value;
	{%endif%}
	switch(value)
	{
	{%for value in enum.values%}
	{%set pvrvk_valuename = value.name|pvrvkify_enum_value(enum.name)%}
	case {{enumname}}::{{pvrvk_valuename}}: return "{{value.name}}";
	{%endfor%}
	default: return "invalid";
	}
}
	{%for group in enum.groups%}{{close_ifdef(group)}}{%endfor%}

{%endif%}{%endmacro%}
{##}
{# ##### MACRO - OUTPUT TYPE: Struct ##### #}
{%macro output_struct(struct)%}
{%for group in struct.groups if struct.name not in FILTERED_STRUCTS%}{{open_ifdef(group)}}{%endfor%}
{%if struct.name not in FILTERED_STRUCTS%}
{%if struct.returnedonly%}
// {{struct.name|pvrvkify_type_name}} is a structure used only as a return type so only getters are defined
{%endif%}
{%set is_union = struct is is_union%}
struct {{struct.name|pvrvkify_type_name}}{{(": private " + struct.name) if not is_union else "" }}
{
{%set parent_object_name =  "_" + struct.name|strip_vk_and_flagbits if is_union else struct.name%}
{# UNION #}
{%if is_union%}
private:
	{{struct.name}} {{parent_object_name}};
public:
{%endif%}
{# DEFAULT CONSTRUCTOR #}
	{{struct.name|pvrvkify_type_name}}(){%if struct.returnedonly%}{}
	{%else%}

	{
		{%for member in struct.members%}
		{%if member.type is is_identifier%}
		{{member|make_setter_name}}({{struct|member_get_default(loop.index0)}});
		{%elif member.type is is_pointer%}
		{{member|make_setter_name}}(nullptr);
		{%elif member.type is is_array%}
		memset({{member.name}}, 0, sizeof({{member.name}}));
		{%else%}
#error Autogenerated type not found.
		{%endif%}
		{%endfor%}
	}
	{%endif%}
{# COPY CONVERSION CONSTRUCTOR #}
	{{struct.name|pvrvkify_type_name}}(const {{struct.name}}& vkType): {{parent_object_name}}(vkType){}
{# CONSTRUCTOR WITH PARAMETERS #}
	{%if not struct.returnedonly%}
	{{struct.name|pvrvkify_type_name}}({{struct.members|map("make_param", struct, False, True)|join(", ")}})
	{
		{%for member in struct.members%}
		{{member|make_setter_name}}({{member|make_param_name}});
		{%else%}
		{%endfor%}
	}
	{%endif%}
{# SPECIAL CONSTRUCTORS #}
{%if struct is struct_has_special_constructors%}
{{struct|struct_output_special_constructors}}
{%endif%}
{# GETTERS AND SETTERS #}
	{%for member in struct.members%}
	{# GETTERS#}
	    {%if member.type is is_identifier%}
    inline {{member.type|make_return_type(True)}} {{member|make_getter_name}}() const { return {{member|gen_cast_to_pvrvk}}{{"" if not struct.category == "union" else parent_object_name + "."}}{{member.name}}; }
        {%elif member.type is is_double_dimenion_array%}
    inline {{member.type|make_return_type(True)}} {{member|make_getter_name}}() const { return {{member|gen_cast_to_pvrvk}}{{"" if not struct.category == "union" else parent_object_name + "."}}{{"&" + member.name + "[0][0]"}}; }
		{%elif member.type is is_array or member.type is is_pointer%}
    inline {{member.type|make_return_type(True)}} {{member|make_getter_name}}() const { return {{member|gen_cast_to_pvrvk}}{{"" if not struct.category == "union" else parent_object_name + "."}}{{member.name}}; }
		{%else%}
#error Autogenerated type not found.
		{%endif%}
	{# SETTERS#}
		{%if not struct.returnedonly%}
			{%if member.type is pass_by_value or member.type is is_pointer%}
	inline {{struct.name|pvrvkify_type_name +"&" if RETURN_STRUCT_FROM_SETTERS else "void"}} {{member|make_setter_name}}({{member|make_param(struct, add_in=True, strip_vk_suffix=True)}}) { this->{{"" if not is_union else parent_object_name + "."}}{{member.name}} = {{member|gen_cast_to_vk}}{{member|make_param_name(True)}};{{ " return this;" if RETURN_STRUCT_FROM_SETTERS else "" }} }
			{%elif member.type is is_identifier%}
	inline {{struct.name|pvrvkify_type_name +"&"  if RETURN_STRUCT_FROM_SETTERS else "void"}} {{member|make_setter_name}}({{member|make_param(struct, add_in=True, strip_vk_suffix=True)}}) { memcpy(&this->{{"" if not is_union else (parent_object_name + ".")}}{{member.name}}, &{{member|make_param_name(True)}}, sizeof(this->{{"" if not is_union else (parent_object_name + ".")}}{{member.name}}));{{ " return this;" if RETURN_STRUCT_FROM_SETTERS else "" }} }
			{%elif member.type is is_array%}
	inline {{struct.name|pvrvkify_type_name +"&"  if RETURN_STRUCT_FROM_SETTERS else "void"}} {{member|make_setter_name}}({{member|make_param(struct, add_in=True, strip_vk_suffix=True)}}) { memcpy(this->{{"" if not is_union else parent_object_name + "."}}{{member.name}}, {{member|make_param_name(True)}}, sizeof(this->{{member.name}}));{{ " return this;" if RETURN_STRUCT_FROM_SETTERS else "" }} }
			{%else%}
#error Autogenerated type not found.
			{%endif%}
		{%endif%}
	{%endfor%}
{# CONVERT TO PVRVK STRUCT #}
	inline {{struct.name}}& get() { return {{parent_object_name if is_union else "*this"}}; }
	inline const {{struct.name}}& get() const { return {{parent_object_name if is_union else "*this"}}; }
};

{%for group in struct.groups%}{{close_ifdef(group)}}{%endfor%}
{%endif%}
{%endmacro%}
{# MACROS SECTION END - TEMPLATE BEGINS #}
// *** THIS FILE IS GENERATED - DO NOT EDIT ***
// See pvrvk_vulkan_wrapper_generator.py for modifications

/*
\brief vulkan.h wrapper used by PVRVk.
\file pvrvk_vulkan_wrapper.h
\author PowerVR by Imagination, Developer Technology Team
\copyright Copyright (c) Imagination Technologies Limited.
*/

/* Corresponding to Vulkan registry file version #{{header_version}}# */

//!\cond NO_DOXYGEN
// clang-format off
#pragma once
#include "vulkan/vulkan.h"

#if defined(VK_USE_PLATFORM_XLIB_KHR) || defined(VK_USE_PLATFORM_XCB_KHR)
// undef these macros from the xlib files, they are breaking the framework types.
#undef Success
#undef Enum
#undef None
#undef Always
#undef byte
#undef char8
#undef ShaderStageFlags
#undef capability
#endif

#include <algorithm>
#include <vector>
#include <stdexcept>
#include <string>
#include <cstring>
#include <cstdio>

#if defined(_WIN32)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <Windows.h>
#define vsnprintf _vsnprintf
#endif

#if defined(__linux__)
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <signal.h>
#endif

#define DEFINE_ENUM_BITWISE_OPERATORS(type_) \
inline type_ operator | (type_ lhs, type_ rhs) \
{ \
	return (type_)(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs)); \
} \
inline type_& operator |= (type_& lhs, type_ rhs) \
{ \
	return lhs = (type_)(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs)); \
} \
inline type_ operator & (type_ lhs, type_ rhs) \
{ \
	return (type_)(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs)); \
} \
inline type_& operator &= (type_& lhs, type_ rhs) \
{ \
	return lhs = (type_)(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs)); \
} \
inline type_ operator ^ (type_ lhs, type_ rhs) \
{ \
	return (type_)(static_cast<uint32_t>(lhs) ^ static_cast<uint32_t>(rhs)); \
} \
inline type_& operator ^= (type_& lhs, type_ rhs) \
{ \
	return lhs = (type_)(static_cast<uint32_t>(lhs) ^ static_cast<uint32_t>(rhs)); \
} \
inline type_ operator <<(type_ lhs, uint32_t rhs) \
{ \
	return (type_)(static_cast<uint32_t>(lhs) << rhs); \
} \
inline type_& operator <<=(type_& lhs, uint32_t rhs) \
{ \
	return lhs = (type_)(static_cast<uint32_t>(lhs) << rhs); \
} \
inline type_ operator >>(type_ lhs, uint32_t rhs) \
{ \
	return (type_)(static_cast<uint32_t>(lhs) >> rhs); \
} \
inline type_& operator >>=(type_& lhs, uint32_t rhs) \
{ \
	return lhs = (type_)(static_cast<uint32_t>(lhs) >> rhs); \
} \
inline bool operator ==(type_ lhs, uint32_t rhs) \
{ \
	return static_cast<uint32_t>(lhs) == rhs; \
} \
inline bool operator !=(type_ lhs, uint32_t rhs) \
{ \
	return static_cast<uint32_t>(lhs) != rhs; \
} \
inline bool operator ==(uint32_t lhs, type_ rhs) \
{ \
	return lhs == static_cast<uint32_t>(rhs); \
}\
inline bool operator !=(uint32_t lhs, type_ rhs) \
{ \
	return lhs != static_cast<uint32_t>(rhs); \
}\
inline type_ operator ~(type_ lhs) \
{ \
	return (type_)(~static_cast<uint32_t>(lhs)); \
}\
inline type_ operator *(uint32_t lhs, type_ rhs) \
{ \
	return (type_)(lhs * static_cast<uint32_t>(rhs)); \
}\
inline type_ operator *(type_ lhs, uint32_t rhs) \
{ \
	return (type_)(static_cast<uint32_t>(lhs) * rhs); \
}\

#define DEFINE_EMPTY_TO_STRING(type_)\
inline std::string to_string(type_ value) \
{ \
	(void)value; \
	return "reserved"; \
} \

namespace pvrvk {


// PVRVk Structures defined in PVRVk/Types.h. These are excluded from autogeneration so we need to forward declare them here 
struct ClearValue;
struct ClearColorValue;
struct ClearAttachment;
struct AttachmentDescription;
struct SubpassDescription;

// PVRVk Basetypes
typedef VkFlags Flags;
typedef VkBool32 Bool32;
typedef VkDeviceSize DeviceSize;
typedef VkSampleMask SampleMask;
typedef VkDeviceAddress DeviceAddress;


template<typename MyEnum>
inline void append_to_string_flag(MyEnum current_value, std::string& current_string, MyEnum flag_to_test, const char* string_to_add)
{
	if(static_cast<uint32_t>(current_value & flag_to_test) != 0)
	{
		if (!current_string.empty()){
			current_string += "|";
		}
		current_string += string_to_add;
	}
}


// PVRVk Bitmasks (Empty)
{%for flag in types | select("is_type_empty_bitmask") %}
	{%if flag.name.replace("Flags", "FlagBits") not in enums | map(attribute="name") %}{{ output_empty_flags_from_type(flag) }}{%endif%}
{%endfor%}

// PVRVk Bitmasks
{%for flag in enums | select("is_enum_flag_bits")%}{{ output_enum_flag(flag) if flag.values|length > 0 else output_empty_flags_from_type(flag)}}{%endfor%}

// PVRVk Enums
{%for flag in enums | reject("is_enum_special")|reject("is_enum_flag_bits") %}{{ output_enum(flag) }}{%endfor%}
// PVRVk Typedefs
{%for alias,name in typeAliases.items() if name in types|select("is_type_empty_bitmask")|map(attribute="name")%}
{%for groups in types | selectattr("name", "equalto", name) | map(attribute = "groups") %}{% for group in groups %}{{open_ifdef(group)}}{%endfor%}{%endfor%}
typedef {{name|pvrvkify_type_name}} {{alias|pvrvkify_type_name}};
{%for groups in types | selectattr("name", "equalto", name) | map(attribute = "groups") %}{% for group in groups %}{{close_ifdef(group)}}{%endfor%}{%endfor%}
{%endfor%}
{%for alias,name in typeAliases.items() if name in enums|select("is_not_enum_flag_bits")|map(attribute="name")%}
{%for groups in enums | selectattr("name", "equalto", name) | map(attribute = "groups") %}{% for group in groups %}{{open_ifdef(group)}}{%endfor%}{%endfor%}
typedef {{name|pvrvkify_type_name}} {{alias|pvrvkify_type_name}};
{%for groups in enums | selectattr("name", "equalto", name) | map(attribute = "groups") %}{% for group in groups %}{{close_ifdef(group)}}{%endfor%}{%endfor%}
{%endfor%}

// PVRVk Format queries: isSrgb()
inline bool isSrgb(Format value)
{
	// This list is sorted by enum values
	const Format srgb_formats[] = {
		{%for format in (enums|selectattr("name", "eq", "VkFormat")|first).values if "_SRGB" in format.name %}
		Format::{{format.name|pvrvkify_enum_value("VkFormat")}},
		{%endfor%}
	};
	return std::binary_search(srgb_formats, srgb_formats + sizeof(srgb_formats)/sizeof(srgb_formats[0]), value);
}

// PVRVk Conversion : ObjectType to DebugReportObjectType
inline DebugReportObjectTypeEXT convertObjectTypeToDebugReportObjectType(ObjectType objectType) { return static_cast<DebugReportObjectTypeEXT>(objectType); }

// PVRVk Conversion : DebugReportObjectType to ObjectType 
inline ObjectType convertDebugReportObjectTypeToObjectType(DebugReportObjectTypeEXT debugReportObjectType) { return static_cast<ObjectType>(debugReportObjectType); }

// PVRVk Structures
{%for struct in types|select("struct") | reject("is_struct_special") | reject("is_struct_skipped") | reject("has_stype_or_pnext") %}{{ output_struct(struct) }}{%endfor%}

// PVRVk Errors
{%set results = (enums|selectattr("name", "eq", "VkResult")|first).values %}
{%set result_all_failures = results|rejectattr("name","eq", "VK_SUCCESS") %}
{%set result_success = results|selectattr("name","eq", "VK_SUCCESS") %}
{%set result_errors = results|selectattr("value","lt_arithmetic", 0) %}
{%set result_non_error_failures = results|selectattr("value","gt_arithmetic", 0) %}

namespace impl {

	/// <summary>Checks whether a debugger can be found for the current running process (on Windows and Linux only).
	/// The prescene of a debugger can be used to provide additional helpful functionality for debugging application issues one of which could be to break in the
	/// debugger when an exception is thrown. Being able to have the debugger break on such a thrown exception provides by far the most seamless and constructive environment for
	/// fixing an issue causing the exception to be thrown due to the full state and stack trace being present at the point in which the issue has occurred rather
	/// than relying on error logic handling.</summary>
	/// <returns>True if a debugger can be found for the current running process else False.</returns>
	inline static bool isDebuggerPresent()
	{
		// only check once for whether the debugger is present as this may not be efficient to determine
		static bool isUsingDebugger = false;
		static bool haveCheckedForDebugger = false;
		if (!haveCheckedForDebugger)
		{
#if defined(_MSC_VER)
			if (IsDebuggerPresent())
			{
				isUsingDebugger = true;
			}
#elif defined(__linux__)
			// reference implementation taken from: https://stackoverflow.com/a/24969863
			char buf[1024];

			int status_fd = open("/proc/self/status", O_RDONLY);
			if (status_fd == -1)
			{
				isUsingDebugger = false;
			}
			else
			{
				ssize_t num_read = read(status_fd, buf, sizeof(buf) - 1);
				if (num_read > 0)
				{
					static const char TracerPid[] = "TracerPid:";
					char* tracer_pid;

					buf[num_read] = 0;
					tracer_pid = strstr(buf, TracerPid);
					if (tracer_pid)
					{
						isUsingDebugger = !!atoi(tracer_pid + sizeof(TracerPid) - 1);
					}
				}
			}
#endif
			haveCheckedForDebugger = true;
		}

		return isUsingDebugger;
	}

	/// <summary>If supported on the platform, makes the debugger break at this line. Used for Assertions on Visual Studio</summary>
	inline void debuggerBreak()
	{
		if (isDebuggerPresent())
		{
#if defined(__linux__)
			{
				raise(SIGTRAP);
			}
#elif defined(_MSC_VER)
			__debugbreak();
#endif
		}
	}
}
/// <summary>Convert Vulkan error code to string</summary>
/// <param name="errorCode">Vulkan error</param>
/// <returns>Error string</returns>
inline char const* vkErrorToStr(Result errorCode)
{
	switch (errorCode)
	{
{%for result in results%}
	case Result::{{result.name|pvrvkify_enum_value("VkResult")}}: return "{{result.name}}";
{%endfor%}
	default: return ("-- Result::UNKNOWN ERROR CODE--");
		break;
	}
}

class Error: public std::runtime_error
{
protected:
	Result _result;
public:
	virtual ~Error() {}
	Error(Result result, const std::string& errorMessage) :
		runtime_error(std::string("[") + vkErrorToStr(result) + ("] : ") + errorMessage), _result(result)
	{
#ifdef DEBUG
		impl::debuggerBreak();
#endif
	}
	Error(Result result, const char* errorMessage = nullptr) :
		runtime_error((std::string("[") + vkErrorToStr(result) + "] : ") + (errorMessage ? errorMessage : "")), _result(result)
	{
#ifdef DEBUG
		impl::debuggerBreak();
#endif
	}
	const char* getErrorMessage() const { return what(); }
	Result getResult() const { return _result; }
	const char* getResultCode() const { return vkErrorToStr(_result); }
};

{%for result in results%}
class {{(result.name|pvrvkify_result)}}: public Error
{
public:
	virtual ~{{result.name|pvrvkify_result }}(){}
	{{result.name|pvrvkify_result }}(const char* errorMessage = nullptr): Error(Result::{{result.name|pvrvkify_enum_value("VkResult")}}, errorMessage) {}
	explicit {{result.name|pvrvkify_result }}(const std::string& errorMessage): Error(Result::{{result.name|pvrvkify_enum_value("VkResult")}}, errorMessage) {}
};
{%endfor%}

namespace impl {
/// <summary>Throw a Vulkan exception if the result is not successful.</summary>
/// <param name="result">A vulkan result code</param>
/// <param name="msg">Throw a corresponding exception if the error code is not success</param>
inline void vkThrowIfFailed(Result result, const char* message = 0)
{
	switch (result)
	{
{%for result in result_all_failures|map(attribute="name") %}
	case Result::{{result|pvrvkify_enum_value("VkResult")}}: throw {{result|pvrvkify_result}}(message);
{%endfor%}
	case Result::e_SUCCESS:
		break;
	default: throw ErrorUnknown(message);
	}
}

/// <summary>Throw a Vulkan exception if the result is not successful.</summary>
/// <param name="result">A vulkan result code</param>
/// <param name="msg">Throw a corresponding exception if the error code is not success</param>
inline void vkThrowIfFailed(VkResult result, const char* message = 0)
{
	vkThrowIfFailed(static_cast<pvrvk::Result>(result), message);
}

/// <summary>Throw a Vulkan exception if the result is not successful.</summary>
/// <param name="result">A vulkan result code</param>
/// <param name="msg">Throw a corresponding exception if the error code is an error</param>
inline void vkThrowIfError(Result result, const char* message = 0)
{
	switch (result)
	{
{%for result in result_errors|map(attribute="name") %}
	case Result::{{result|pvrvkify_enum_value("VkResult")}}: throw {{result|pvrvkify_result}}(message);
{%endfor%}
	case Result::e_SUCCESS:
{%for result in result_non_error_failures|map(attribute="name") %}
	case Result::{{result|pvrvkify_enum_value("VkResult")}}:
{%endfor%}
		break;
	default: throw ErrorUnknown(message);
	}
}
}// namespace impl

{%set instance_extensions = extensions|selectattr("extensionType", "eq", "instance")|list%}
{%set device_extensions = extensions|selectattr("extensionType", "eq", "device")|list%}

// Generated extension tables which can be used to determine support for enabled extensions
/// <summary>Instance extension table.</summary>
struct InstanceExtensionTable
{
public:
{%for ext in instance_extensions %}
	// {{ext.name}}
	bool {{ext.name|pvrvkify_extension_name_to_var}}Enabled = false;
{%endfor%}

void setEnabledExtension(const std::string& extension)
{
	std::string instanceExtensions[31] = {
{%for ext in instance_extensions %}
		"{{ext.name}}",
{%endfor%}
	};

	bool* instanceExtensionsFlags[31] = {
{%for ext in instance_extensions %}
		&{{ext.name|pvrvkify_extension_name_to_var}}Enabled,
{%endfor%}
	};

	for(uint32_t i = 0; i < {{instance_extensions|length}}; ++i)
	{
		if (extension == instanceExtensions[i])
		{
			*instanceExtensionsFlags[i] = true;
		}
	}
}

void setEnabledExtensions(const std::vector<std::string>& extensions)
{
	for(uint32_t i = 0; i < static_cast<uint32_t>(extensions.size()); ++i)
	{
		setEnabledExtension(extensions[i]);
	}
}

void setEnabledExtensions(const std::vector<const char*>& extensions)
{
	for(uint32_t i = 0; i < static_cast<uint32_t>(extensions.size()); ++i)
	{
		setEnabledExtension(extensions[i]);
	}
}
};

/// <summary>Device extension table.</summary>
struct DeviceExtensionTable
{
public:
{%for ext in device_extensions %}
	// {{ext.name}}
	bool {{ext.name|pvrvkify_extension_name_to_var}}Enabled = false;
{%endfor%}

void setEnabledExtension(const std::string& extension)
{
	std::string deviceExtensions[174] = {
{%for ext in device_extensions %}
		"{{ext.name}}",
{%endfor%}
	};

	bool* deviceExtensionsFlags[174] = {
{%for ext in device_extensions %}
		&{{ext.name|pvrvkify_extension_name_to_var}}Enabled,
{%endfor%}
	};

	for(uint32_t i = 0; i < 174; ++i)
	{
		if (extension == deviceExtensions[i])
		{
			*deviceExtensionsFlags[i] = true;
		}
	}
}

void setEnabledExtensions(const std::vector<std::string>& extensions)
{
	for(uint32_t i = 0; i < static_cast<uint32_t>(extensions.size()); ++i)
	{
		setEnabledExtension(extensions[i]);
	}
}

void setEnabledExtensions(const std::vector<const char*>& extensions)
{
	for(uint32_t i = 0; i < static_cast<uint32_t>(extensions.size()); ++i)
	{
		setEnabledExtension(extensions[i]);
	}
}
};

} // namespace pvrvk
// clang-format on
//!\endcond
